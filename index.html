<!DOCTYPE html>
<html lang="en" >

<head>
  <meta charset="UTF-8">
  <title>FCC: Technical Documentation Final</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
<title>Technical Document</title>
  
  
      <link rel="stylesheet" href="css/style.css">

  
</head>

<body>

  <head>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">
</head>

<div class="container-fluid">
  
    <!-- navigation -->
  
    <nav id="navbar">
      <div>
      <header>Window sizes and scrolling</header>
      </div>
      <div id="nav">
      <a class="nav-link" href="#Width/height_of_the_window">Width/height of the window</a>
      <a class="nav-link" href="#Width/height_of_the_document">Width/height of the document</a>
      <a class="nav-link" href="#Get_the_current_scroll">Get the current scroll</a>
      <a class="nav-link" href="#Scrolling:_scrollTo,_scrollBy,_scrollIntoView">Scrolling: scrollTo, scrollBy, scrollIntoView</a>
      <a class="nav-link" href="#scrollIntoView">scrollIntoView</a>
      <a class="nav-link" href="#Forbid_the_scrolling">Forbid the scrolling</a>
      <a class="nav-link" href="#Summary">Summary</a>
        <div>
    </nav>

      <!-- main body of document -->
  <div class="container">
    <main id="main-doc">
      
      <header><h1>Window sizes and scrolling</h1></header>
      <p>How to find out the width of the browser window? How to get the full height of the document, including the scrolled out part? How to scroll the page using JavaScript?</p>
      <p>From the DOM point of view, the root document element is document.documentElement. That element corresponds to &lt;html&gt; and has geometry properties described in the previous chapter. For some cases we can use it, but there are additional methods and peculiarities important enough to consider.</p>
      
      <section class="main-section" id="Width/height_of_the_window">
        <header><h2>Width/height of the window</h2></header>
        <p>Properties clientWidth/clientHeight of document.documentElement is exactly what we want here:</p>
        <img src="http://javascript.info/article/size-and-scroll-window/document-client-width-height.png">
        <p>For instance, this button shows the height of your window:</p>
        <p><button onclick="alert(document.documentElement.clientHeight)">alert(document.documentElement.clientHeight)</button></p>
        
        <h4>Not window.innerWidth/Height</h4>
        <p>Browsers also support properties window.innerWidth/innerHeight. They look like what we want. So what’s the difference?</p>
        <p>If there’s a scrollbar occupying some space, clientWidth/clientHeight provide the width/height inside it. In other words, they return width/height of the visible part of the document, available for the content.</p>
        <p>And window.innerWidth/innerHeight ignore the scrollbar.</p>
        <p>If there’s a scrollbar, and it occupies some space, then these two lines show different values:</p>
        <code>alert( window.innerWidth ); // full window width</code><br><code>
alert( document.documentElement.clientWidth ); // window width minus the scrollbar</code>
        <p>In most cases we need the available window width: to draw or position something. That is: inside scrollbars if there are any. So we should use documentElement.clientHeight/Width.</p>
        
        <h4>DOCTYPE is important</h4>
        <p>Please note: top-level geometry properties may work a little bit differently when there’s no <!DOCTYPE HTML> in HTML. Odd things are possible.</p>
        <p>In modern HTML we should always write DOCTYPE. Generally that’s not a JavaScript question, but here it affects JavaScript as well.</p>
      </section>
      <section class="main-section" id="Width/height_of_the_document">
        <header><h2>Width/height of the document</h2></header>
        <p>Theoretically, as the root document element is documentElement.clientWidth/Height, and it encloses all the content, we could measure its full size as documentElement.scrollWidth/scrollHeight.</p>
        <p>These properties work well for regular elements. But for the whole page these properties do not work as intended. In Chrome/Safari/Opera if there’s no scroll, then documentElement.scrollHeight may be even less than documentElement.clientHeight! For regular elements that’s a nonsense.</p>
        <p>To have a reliable full window size, we should take the maximum of these properties:</p>
        
        <code>let scrollHeight = Math.max(</code><br>
        <code>  document.body.scrollHeight, document.documentElement.scrollHeight,
</code><br>
        <code>  document.body.offsetHeight, document.documentElement.offsetHeight,
</code><br>
        <code>  document.body.clientHeight, document.documentElement.clientHeight
</code><br>
        <code>);
</code><br>
        <code>alert('Full document height, with scrolled out part: ' + scrollHeight);
</code>
        
        <p>Why so? Better don’t ask. These inconsistencies come from ancient times, not a “smart” logic.</p>
      </section>
      <section class="main-section" id="Get_the_current_scroll">
        <header><h2>Get the current scroll</h2></header>
        <p>Regular elements have their current scroll state in elem.scrollLeft/scrollTop.</p>
        <p>What’s with the page? Most browsers provide documentElement.scrollLeft/Top for the document scroll, but Chrome/Safari/Opera have bugs (like 157855, 106133) and we should use document.body instead of document.documentElement there.</p>
        <p>Luckily, we don’t have to remember these peculiarities at all, because of the special properties window.pageXOffset/pageYOffset:</p>
        
        <code>alert('Current scroll from the top: ' + window.pageYOffset);
</code><br>
        <code>alert('Current scroll from the left: ' + window.pageXOffset);
</code>
        <p>These properties are read-only.</p>
      </section>
      <section class="main-section" id="Scrolling:_scrollTo,_scrollBy,_scrollIntoView">
        <header><h2>Scrolling: scrollTo, scrollBy, scrollIntoView</h2></header>
        <h4>Important:</h4>
        <p>To scroll the page from JavaScript, its DOM must be fully built.</p>
        <p>For instance, if we try to scroll the page from the script in &lt;head&gt;, it won’t work.</p>
        
        <p>Regular elements can be scrolled by changing scrollTop/scrollLeft.</p>
        <p>We can do the same for the page:</p>
          <ul>
            <li>For all browsers except Chrome/Safari/Opera: modify document.documentElement.scrollTop/Left.</li>
            <li>In Chrome/Safari/Opera: use document.body.scrollTop/Left instead.</li>
          </ul>
        <p>It should work, but smells like cross-browser incompatibilities. Not good. Fortunately, there’s a simpler, more universal solution: special methods window.scrollBy(x,y) and window.scrollTo(pageX,pageY).</p>
          <ul>
            <li><p>The method scrollBy(x,y) scrolls the page relative to its current position. For instance, scrollBy(0,10) scrolls the page 10px down.</p>
              <p>The button below demonstrates this:</p>
              <p><button onclick="window.scrollBy(0,10)">window.scrollBy(0,10)</button></p></li>
            <li><p>The method scrollTo(pageX,pageY) scrolls the page relative to the document top-left corner. It’s like setting scrollLeft/scrollTop.</p>
              <p>To scroll to the very beginning, we can use scrollTo(0,0).</p>
              <p><button onclick="window.scrollTo(0,0)">window.scrollTo(0,0)</button></p></li>
          </ul>
        <p>These methods work for all browsers the same way.</p>
      </section>
      <section class="main-section" id="scrollIntoView">
        <header><h2>scrollIntoView</h2></header>
        <p>For completeness, let’s cover one more method: elem.scrollIntoView(top).</p>
        <p>The call to elem.scrollIntoView(top) scrolls the page to make elem visible. It has one argument:</p>
          <ul>
            <li>if top=true (that’s the default), then the page will be scrolled to make elem appear on the top of the window. The upper edge of the element is aligned with the window top.</li>
            <li>if top=false, then the page scrolls to make elem appear at the bottom. The bottom edge of the element is aligned with the window bottom.</li>
          </ul>
        <p></p>
        <p></p>
      </section>
      <section class="main-section" id="Forbid_the_scrolling">
        <header><h2>Forbid the scrolling</h2></header>
        <p>Sometimes we need to make the document “unscrollable”. For instance, when we need to cover it with a large message requiring immediate attention, and we want the visitor to interact with that message, not with the document.</p>
        <p>To make the document unscrollable, its enough to set document.body.style.overflow = "hidden". The page will freeze on its current scroll.</p>
        <p>Try it:</p>
        <p><button onclick="document.body.style.overflow = 'hidden'"><code>document.body.style.overflow = 'hidden'</code></button></p>
        <p><button onclick="document.body.style.overflow = ''"><code>document.body.style.overflow = ''</code></button></p>
        <p>The first button freezes the scroll, the second one resumes it.</p>
        <p>We can use the same technique to “freeze” the scroll for other elements, not just for document.body.</p>
        <p>The drawback of the method is that the scrollbar disappears. If it occupied some space, then that space is now free, and the content “jumps” to fill it.</p>
        <p>That looks a bit odd, but can be worked around if we compare clientWidth before and after the freeze, and if it increased (the scrollbar disappeared) then add padding to document.body in place of the scrollbar, to keep the content width same.</p>
      </section>
      <section class="main-section" id="Summary">
        <header><h2>Summary</h2></header>
        <p>Geometry:</p>
          <ul>
            <li>Width/height of the visible part of the document (content area width/height): document.documentElement.clientWidth/Height</li>
            <li>Width/height of the whole document, with the scrolled out part:</li>
        </ul>
          <code>let scrollHeight = Math.max(
</code><br>
          <code>  document.body.scrollHeight, document.documentElement.scrollHeight,
</code><br>
          <code>  document.body.offsetHeight, document.documentElement.offsetHeight,
</code><br>
          <code>  document.body.clientHeight, document.documentElement.clientHeight
</code><br>
          <code>);
</code>
        <p>Scrolling:</p>
          <ul>
            <li>Read the current scroll: window.pageYOffset/pageXOffset.</li>
            <li>Change the current scroll:</li>
            <ul>
              <li>window.scrollTo(pageX,pageY) – absolute coordinates,</li>
              <li>window.scrollBy(x,y) – scroll relative the current place,</li>
              <li>elem.scrollIntoView(top) – scroll to make elem visible (align with the top/bottom of the window).</li>
            </ul>
        </ul>
      </section>
    </main>
  </div> <!-- End of container -->
</div> <!-- End of container -->
  
  

</body>

</html>
